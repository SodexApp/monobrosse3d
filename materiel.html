<!DOCTYPE html>
<html>
  <head>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.0.0/html2canvas.min.js"></script> -->
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/renderers/CSS3DRenderer.js"></script>

    <link rel="stylesheet" href="myStyle.css">
    
   
  </head>
 
  <body > 
   

    <div>
      <canvas id = "myCanvas"></canvas>
<button id= "animate" hidden>animer</button>
<button id="stopBtn" hidden>Stop Animation</button>
<button id = "sol" hidden>sol</button>
<button id = "disc" hidden>disque</button>
   
            
      </div>
    <script src = "createScene.js"></script>

<!--     // add script basicscene////////////////////////////// -->
    <script>
      
     var image = "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/disque_s3m.jpg?v=1675426903770";
     var url = "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/materielLM.mp4?v=1680014043586";//video materiel
     var script = document.createElement("script");
    script.src ="basicScene.js?url=" + encodeURIComponent(url)+"&image=" + encodeURIComponent(image);
    document.body.appendChild(script);
    </script> 
   
<!--    <script src="basicScene.js?url=https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/materielLM.mp4?v=1680014043586"></script> -->

<!--  add script monobrosse    -->
    <script>
  
  //add disque mono cylindrique
      // create a circle with radius of 50 double face  
      const circleGeometry = new THREE.CylinderGeometry(0.8, 0.8,0.2, 15);
      const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide  });
      const circle = new THREE.Mesh(circleGeometry, circleMaterial);   
      circle.name = "disque"
      scene.add(circle);
      circle.position.set(0,0.1,0);
         
          window.onload = function(){    
            loadObject();
            //loadReservoir();
            animateOrbitControls();
          
          }; 
      
 
  var monobrosse; // crÃ©er l'objet monobrosse pour l'utiliser apres dans animate et change texture
  var reservoir;
  const groupMono = new THREE.Group();
      
      groupMono.add(circle);
      
        // add imported object  monobrosse 
      
  function handleLoadedObject(gltf) {
  var gltfMat = gltf.material;
  if (Array.isArray(gltfMat)) {
    console.log("The object has multiple materials.");
  } else {
    console.log("The object has a single material.");
  }
}
      // wrap the loader code in a separate function
      function loadObject(){
      var loader = new THREE.GLTFLoader();
      loader.load(
      "https://cdn.glitch.global/75b2ee89-061d-43b5-9e9f-59fd1a843032/monoPaintDisc.glb?v=1673883984689",
       
        function (gltf) {
          monobrosse= gltf;
          console.log("gltf loaded successfully");
          // console.log(gltf.scene.scale);
         //scene.add(monobrosse.scene);
          var gltfObject = monobrosse.scene.children[0]; 
          //console.log(gltfObject);    
          gltfObject.position.set(-0.2,-0.2,-0.7);
            // Position the camera  
          // renderer.render(scene, camera);
          //   camera.position.z = -5;  
            groupMono.add(gltfObject);
              
         handleLoadedObject(monobrosse);
         // console.log(monobrosse);
          return monobrosse;
        },
        undefined,
        function (error) {
          console.log("Error loading gltf:", error);
        }      
      );  
   }  
  
      scene.add(groupMono);
          
//       mouvements de bascule
      let animationId;
document.getElementById("animate").addEventListener("click",animate);
      
  // Define variables for the object, radius, and angle
const object = new THREE.Object3D();
const radius = 5;
let angle = 0;
      
var cameraInitialPos = new THREE.Vector3(2, 5, -10);
var cameraNewPos = new THREE.Vector3(5, 3, -8);

function rotateYAndX() {
  
   groupMono.rotation.y += 0.015;
   // calculate interpolation factor based on current rotation angle
  var interpFactor = Math.min(groupMono.rotation.y / (Math.PI / 2), 1)
  
 
  if (groupMono.rotation.y >= Math.PI) {
    groupMono.rotation.y = Math.PI;
    rotateX(); // call rotateZ() when rotateY() is done
  } else {
    requestAnimationFrame(rotateYAndX); // keep calling rotateYAndZ() until condition is met
  }

  // interpolate camera position between initial and new positions
  var cameraPos = new THREE.Vector3().lerpVectors(cameraInitialPos, cameraNewPos, interpFactor);

  // set camera position and lookAt target
  camera.position.copy(cameraPos);
  camera.lookAt(groupMono.position);

}
function rotateX() {

  groupMono.position.y = 1.4;
  groupMono.rotation.x += 0.015;
  if (groupMono.rotation.x >= Math.PI/2.1) {
    groupMono.rotation.x = Math.PI/2.1;
    renderer.render(scene, camera); // render the scene when both rotations are done
  } else {
    requestAnimationFrame(rotateX); // keep calling rotateZ() until condition is met
  }
}

rotateYAndX(); // start the sequence by calling rotateYAndZ()
    
  
   // add raycaster
var raycaster = new THREE.Raycaster(); // Create a new Raycaster
      
       if(isMobile())  {
   
   console.log("ismobile"+isMobile());
   console.log(navigator.userAgent);
window.addEventListener('touchstart', onTouchStart, false);
// window.addEventListener('touchmove', onTouchMove, false);
   
 } else{
    
window.addEventListener('mousemove', onMouseMove, false); // Add a mousemove event listener to the window object
window.addEventListener('click', onClick, false); // Add a click event listener to the window object
 } 
    
function isMobile(){
// Check the user agent string to see if it contains "Mobile"
  return /Mobi/i.test(navigator.userAgent);  
}
    
var mouse = new THREE.Vector2(); // Create a new Vector2 to store the mouse coordinates



function onMouseMove(event) {
  // Calculate the mouse position relative to the viewport
   
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}



function onClick(event) {
  // Use the Raycaster to check for intersections between the mouse and the objects in the scene
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(scene.children, true);

  // If there is at least one intersection, trigger your function
  if (intersects.length > 0) {
    
    var object = intersects[0].object;
     console.log(object);
    
    if(object.name === "disque"){    
     var lastColorClickedIndex = 0;
     changeColor();
      // var colors =["green","red","blue","lightgreen","purple","white","black"]
    }
    else if(object.name === "sol"){
      var lastClickedTextureIndex = 0;  
      switchTexture();
    }
    else if (object.name === 'videoPlane') {
            if (clip.paused) {
      clip.play();
    } else {
      clip.pause();
    }
  } 
 }
}
      
      function onTouchStart(event){
           event.preventDefault();

  const touch = event.touches[ 0 ];
  const x = ( touch.clientX / window.innerWidth ) * 2 - 1;
  const y = - ( touch.clientY / window.innerHeight ) * 2 + 1;

  raycaster.setFromCamera( new THREE.Vector2( x, y ), camera );
          // If there is at least one intersection, trigger your function
          var intersects = raycaster.intersectObjects(scene.children, true);
  if (intersects.length > 0) {
    
    var object = intersects[0].object;
     console.log(object);
    
    if(object.name === "disque"){    
     var lastColorClickedIndex = 0;
     changeColor();
      // var colors =["green","red","blue","lightgreen","purple","white","black"]
    }
    else if(object.name === "sol"){
      var lastClickedTextureIndex = 0;  
      switchTexture();
    }
    else if (object.name === 'videoPlane') {
    // pause the video
    if (clip.paused) {
      clip.play();
    } else {
      clip.pause();
    }
     } 
   }
 }
           
      // function chgt couleur disque
         var lastColorClickedIndex = 0
        function changeColor(color) {
        
        var colors =["green","red","blue","lightgreen","purple","white","black"]
      
        var color = colors[(lastColorClickedIndex + 1) % colors.length]; 
       lastColorClickedIndex = (lastColorClickedIndex + 1) % colors.length
        var disc = circle.material;
      // Update the material's color property
       disc.color.set(color);
      // Update the material
      material.needsUpdate = true;
          localStorage.setItem("colorDisc",color);
      }
      
    
// function switchTexture() { 
 
//   var textures = ["https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/parquet.jpg?v=1675152195035",
//                   "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/carrelage.jpg?v=1675268522240",
//                   "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/thermoplastique.jpg?v=1675343582559",
//                  "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/marbre.jpg?v=1675343654491",
//                  "https://cdn.glitch.global/5bd793e6-3c08-44e5-bec2-8b45b68b56c7/wool.jpg?v=1675343763042"];

// //   // Get the next texture
//    var texture = textures[(lastClickedTextureIndex + 1) % textures.length]; 
// //   console.log((lastClickedTextureIndex + 1) % textures.length)
//   console.log(texture)
//   var appliedTexture = new THREE.TextureLoader().load(texture);

//   // Update the last clicked texture index
// lastClickedTextureIndex = (lastClickedTextureIndex + 1) % textures.length;
  
//    // Get the material of the object you want to change
//  var materialSol = planeSol.material;    
//   // Update the material's map property to switch to the new texture
//    materialSol.map = appliedTexture
//   // Update the material
//   materialSol.needsUpdate = true;
//   localStorage.setItem('textureSol',texture);
//   console.log(localstorage.texture)
// }
      </script>


   

</body> 
</html>